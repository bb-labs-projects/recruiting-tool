---
phase: 01-foundation-and-auth
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/app/api/auth/magic-link/request/route.ts
  - src/app/api/auth/magic-link/verify/route.ts
  - src/app/api/auth/logout/route.ts
  - src/app/api/auth/me/route.ts
  - src/actions/auth.ts
  - src/lib/email/magic-link-email.tsx
  - src/lib/auth/security-log.ts
  - src/lib/auth/request-magic-link.ts
autonomous: true
user_setup:
  - service: resend
    why: "Transactional email for magic link delivery"
    env_vars:
      - name: RESEND_API_KEY
        source: "Resend Dashboard -> API Keys -> Create API Key"
      - name: EMAIL_FROM
        source: "Must be a verified domain/email in Resend. For testing: use onboarding@resend.dev"
    dashboard_config:
      - task: "Create a Resend account and verify your sending domain"
        location: "https://resend.com -> Sign up -> Domains -> Add Domain"

must_haves:
  truths:
    - "POST /api/auth/magic-link/request creates a token, stores its hash, and sends an email"
    - "POST /api/auth/magic-link/request always returns success (prevents email enumeration)"
    - "POST /api/auth/magic-link/request respects rate limiting (5 per email per hour)"
    - "POST /api/auth/magic-link/verify validates the token hash, creates a session, and sets a cookie"
    - "POST /api/auth/magic-link/verify rejects expired tokens with a clear error message"
    - "POST /api/auth/magic-link/verify rejects already-used tokens with a clear error message"
    - "POST /api/auth/logout destroys the session cookie and invalidates the DB session"
    - "GET /api/auth/me returns current user data or 401"
    - "Server action requestMagicLink validates email and returns structured state"
    - "All auth events are logged with structured security event format"
    - "Server action and API route share magic link request logic via a common helper"
  artifacts:
    - path: "src/app/api/auth/magic-link/request/route.ts"
      provides: "POST handler for magic link requests"
      exports: ["POST"]
    - path: "src/app/api/auth/magic-link/verify/route.ts"
      provides: "POST handler for magic link verification"
      exports: ["POST"]
    - path: "src/app/api/auth/logout/route.ts"
      provides: "POST handler for logout"
      exports: ["POST"]
    - path: "src/app/api/auth/me/route.ts"
      provides: "GET handler for current user"
      exports: ["GET"]
    - path: "src/actions/auth.ts"
      provides: "Server action for magic link form"
      exports: ["requestMagicLink"]
    - path: "src/lib/email/magic-link-email.tsx"
      provides: "Email sending function"
      exports: ["sendMagicLinkEmail"]
    - path: "src/lib/auth/security-log.ts"
      provides: "Structured security event logging"
      exports: ["logSecurityEvent"]
    - path: "src/lib/auth/request-magic-link.ts"
      provides: "Shared magic link request logic for API route and server action"
      exports: ["handleMagicLinkRequest"]
  key_links:
    - from: "src/app/api/auth/magic-link/request/route.ts"
      to: "src/lib/auth/request-magic-link.ts"
      via: "handleMagicLinkRequest import"
      pattern: "import.*handleMagicLinkRequest.*request-magic-link"
    - from: "src/actions/auth.ts"
      to: "src/lib/auth/request-magic-link.ts"
      via: "handleMagicLinkRequest import"
      pattern: "import.*handleMagicLinkRequest.*request-magic-link"
    - from: "src/app/api/auth/magic-link/request/route.ts"
      to: "src/lib/auth/security-log.ts"
      via: "logSecurityEvent import"
      pattern: "import.*logSecurityEvent.*security-log"
    - from: "src/app/api/auth/magic-link/verify/route.ts"
      to: "src/lib/auth/session.ts"
      via: "createSession import"
      pattern: "import.*createSession.*session"
    - from: "src/app/api/auth/magic-link/verify/route.ts"
      to: "src/lib/auth/security-log.ts"
      via: "logSecurityEvent import"
      pattern: "import.*logSecurityEvent.*security-log"
---

<objective>
Implement the auth API routes, server action, email sending, and security event logging -- the complete backend for the magic link flow.

Purpose: These routes are the server-side half of authentication. They handle token lifecycle (create, verify, invalidate), session management (create, destroy, read), and email delivery. The server action provides the form handler that the login UI will call. Structured security logging provides an audit trail for all auth events.

Output: Four API routes, one server action, one email function, one security logging utility, and one shared helper that together implement the full magic link authentication flow with audit logging.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-and-auth/01-RESEARCH.md
@01-magic-link-auth.md

Depends on Plan 01-02 artifacts:
- src/lib/auth/session.ts (encrypt, decrypt, createSession, deleteSession)
- src/lib/auth/magic-link.ts (generateToken, hashToken)
- src/lib/auth/rate-limit.ts (checkRateLimit)
- src/lib/auth/constants.ts (AUTH_CONSTANTS)
- src/lib/dal.ts (verifySession, getUser)
- src/lib/db/schema.ts (users, magicLinkTokens, sessions)
- src/lib/db/index.ts (db)

Key design decisions:
- Always return success on magic link request (prevent email enumeration)
- Auto-create users on first magic link request (default role: candidate)
- Token stored as SHA-256 hash only (never store raw token)
- Rate limit by userId, checked via DB query
- Verify endpoint is POST only (not GET -- email prefetch protection)
- Session created in DB + encrypted cookie set
- Use Zod for input validation
- Use useActionState-compatible server action signature
- Structured security event logging on all auth events (per spec Section 7)
- Shared helper for magic link request logic (DRY between API route and server action)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create security logger, shared helper, and email template</name>
  <files>
    src/lib/auth/security-log.ts
    src/lib/auth/request-magic-link.ts
    src/lib/email/magic-link-email.tsx
  </files>
  <action>
    1. Create `src/lib/auth/security-log.ts`:

       Define SecurityEvent type matching the spec (Section 7 of 01-magic-link-auth.md):
       ```typescript
       type SecurityEventType =
         | 'magic_link_requested'
         | 'magic_link_verified'
         | 'magic_link_expired'
         | 'magic_link_invalid'
         | 'session_created'
         | 'session_expired'
         | 'logout'

       interface SecurityEvent {
         event: SecurityEventType
         userId: string | null
         email: string
         ip: string
         userAgent: string
         timestamp: string  // ISO8601
         success: boolean
         failureReason?: string
       }
       ```

       Export function `logSecurityEvent(event: SecurityEvent): void`:
       - Uses structured console.log with JSON.stringify
       - Format: `console.log(JSON.stringify({ ...event, _type: 'security_event' }))`
       - The `_type` field enables log aggregation tools (Vercel logs, Datadog, etc.) to filter security events
       - This is intentionally simple -- no external service. Console.log in production on Vercel is captured by Vercel Logs. Can upgrade to a dedicated logging service later.

       Also export a convenience helper `buildSecurityContext(request: Request): { ip: string; userAgent: string }`:
       - Extract IP from request headers: x-forwarded-for (first value) or x-real-ip or 'unknown'
       - Extract userAgent from request headers: user-agent or 'unknown'
       - This avoids duplicating header extraction in every route

    2. Create `src/lib/auth/request-magic-link.ts`:

       Add `import 'server-only'`

       This file contains the shared logic that BOTH the API route and server action call, avoiding duplication.

       Import db, users table, magicLinkTokens table from schema.
       Import generateToken, hashToken from auth/magic-link.
       Import checkRateLimit from auth/rate-limit.
       Import sendMagicLinkEmail from email.
       Import AUTH_CONSTANTS from auth/constants.
       Import logSecurityEvent from auth/security-log.
       Import eq from 'drizzle-orm'.

       Define and export result type:
       ```typescript
       type MagicLinkResult =
         | { success: true }
         | { success: false; error: string; rateLimited?: boolean }
       ```

       Export async function `handleMagicLinkRequest(params: { email: string; ip: string; userAgent: string }): Promise<MagicLinkResult>`:
       a. Normalize email to lowercase and trim whitespace
       b. Look up user by email in users table
       c. If user not found: auto-create user with role='candidate', emailVerified=false
       d. If user found but is not active (isActive=false): log security event and return { success: true } (no enumeration leak)
       e. Check rate limit via checkRateLimit(userId)
       f. If rate limited: log 'magic_link_requested' with success=false, return { success: false, error: "Too many requests. Please try again later.", rateLimited: true }
       g. Generate token via generateToken()
       h. Insert into magicLinkTokens: userId, tokenHash, expiresAt (now + 10 min from AUTH_CONSTANTS), ipAddress, userAgent
       i. Send email via sendMagicLinkEmail(email, token) -- the raw token goes in the email, NOT the hash
       j. Log 'magic_link_requested' with success=true
       k. Return { success: true }
       l. Wrap everything in try/catch. On error, log it and return { success: false, error: "Something went wrong. Please try again." }

    3. Create `src/lib/email/magic-link-email.tsx`:

       Import Resend from 'resend'.

       Export async function `sendMagicLinkEmail(email: string, token: string): Promise<void>`:
       - Construct magic link URL: `${process.env.APP_URL}/auth/verify?token=${token}`
       - Initialize Resend client with process.env.RESEND_API_KEY
       - Send email with:
         - from: `${process.env.APP_NAME} <${process.env.EMAIL_FROM}>`
         - to: [email]
         - subject: `Sign in to ${process.env.APP_NAME}`
         - html: Professional template with:
           - Heading: "Sign in to [App Name]"
           - Body: "Click the button below to sign in. This link expires in 10 minutes."
           - CTA button: Styled link to magic link URL with text "Sign In"
           - Footer: "If you didn't request this email, you can safely ignore it."
           - Security notes: "This link can only be used once" and "It expires in 10 minutes"
       - On error, throw with descriptive message

       NOTE: Use inline HTML for the email template. We can upgrade to @react-email/components later if needed, but inline HTML is simpler and works reliably across email clients.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - src/lib/auth/security-log.ts exports logSecurityEvent and buildSecurityContext
    - src/lib/auth/request-magic-link.ts exports handleMagicLinkRequest
    - src/lib/email/magic-link-email.tsx exports sendMagicLinkEmail
    - Security log function outputs valid JSON with _type: 'security_event'
    - handleMagicLinkRequest handles: user lookup, auto-create, rate limit, token generation, email sending, and logging
    - Email template includes magic link URL with token parameter
  </verify>
  <done>
    Security logging utility produces structured JSON events for all auth actions. Shared helper encapsulates the full magic link request flow (user lookup, rate limit, token generation, email). Email function sends branded magic link emails via Resend. These are the building blocks for the API routes and server action.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth API routes and server action</name>
  <files>
    src/app/api/auth/magic-link/request/route.ts
    src/app/api/auth/magic-link/verify/route.ts
    src/app/api/auth/logout/route.ts
    src/app/api/auth/me/route.ts
    src/actions/auth.ts
  </files>
  <action>
    1. Create `src/app/api/auth/magic-link/request/route.ts`:

       POST handler that:
       a. Parses and validates body with Zod: { email: string (valid email) }
       b. If validation fails, return 400 { error: validation message }
       c. Extract IP and userAgent via buildSecurityContext(request)
       d. Call handleMagicLinkRequest({ email, ip, userAgent })
       e. If result is rate limited: return 429 { error: result.error }
       f. Return 200 { success: true, message: "If this email is registered, a login link has been sent." }
       g. Wrap in try/catch, return 500 on unexpected error

       IMPORTANT: The response message is deliberately vague to prevent email enumeration.

    2. Create `src/app/api/auth/magic-link/verify/route.ts`:

       POST handler that:
       a. Parses body with Zod: { token: string }
       b. Extract IP and userAgent via buildSecurityContext(request)
       c. Hash the token via hashToken(token)
       d. Query magicLinkTokens: find by tokenHash WHERE usedAt IS NULL
       e. If not found: log 'magic_link_invalid' event, return 401 { error: "Invalid or already used token." }
       f. If found but expiresAt < now: log 'magic_link_expired' event, return 401 { error: "This link has expired. Please request a new one." }
       g. Mark token as used: UPDATE usedAt = NOW()
       h. Look up the user by userId from the token record
       i. Update user: emailVerified = true, lastLoginAt = NOW()
       j. Create a session record in sessions table: userId, tokenHash (new session token hash using generateToken), expiresAt (now + 7 days), ipAddress, userAgent
       k. Call createSession(session.id, user.id, user.role) to set the encrypted cookie
       l. Log 'magic_link_verified' and 'session_created' events
       m. Determine redirect path: use token.redirectPath if set, otherwise default based on role (admin -> /admin, employer -> /employer, candidate -> /candidate)
       n. Return 200 { success: true, redirectTo: redirectPath }

       IMPORTANT: Steps g through k should ideally be atomic. Since we're using neon-http (no interactive transactions), do them sequentially. The usedAt update happens first to prevent race conditions with concurrent verify attempts.

    3. Create `src/app/api/auth/logout/route.ts`:

       POST handler that:
       a. Read and decrypt the session cookie
       b. Extract IP and userAgent via buildSecurityContext(request)
       c. If valid session: delete session record from sessions table WHERE id = sessionId
       d. Call deleteSession() to clear the cookie
       e. Log 'logout' event
       f. Return 200 { success: true }

    4. Create `src/app/api/auth/me/route.ts`:

       GET handler that:
       a. Read and decrypt the session cookie
       b. If no valid session: return 401 { error: "Not authenticated" }
       c. Query user by userId from session payload
       d. If no user found: return 401 { error: "Not authenticated" }
       e. Return 200 { user: { id, email, role, emailVerified } }

       NOTE: This does NOT use the DAL (which redirects on failure). This is an API route that should return JSON errors, not redirect.

    5. Create `src/actions/auth.ts`:

       Add 'use server' directive at top.

       Import Zod for validation.
       Import handleMagicLinkRequest from '@/lib/auth/request-magic-link'.

       Define and export the MagicLinkState type:
       ```
       type MagicLinkState = {
         success?: boolean
         error?: string
       } | undefined
       ```

       Define RequestMagicLinkSchema with Zod:
       - email: z.string().email('Please enter a valid email address')

       Export async function `requestMagicLink(prevState: MagicLinkState, formData: FormData): Promise<MagicLinkState>`:
       - Extract and validate email from formData using Zod
       - If validation fails, return { error: fieldError }
       - Call handleMagicLinkRequest({ email, ip: 'server-action', userAgent: 'server-action' })
         Note: Server actions don't have easy access to request headers. Use 'server-action' as placeholder -- the security log still records the event, just without client IP. This is acceptable because the server action is called from the same origin.
       - If result is not successful and rateLimited: return { error: "Too many login attempts. Please try again later." }
       - If result is not successful: return { error: result.error }
       - Return { success: true }
       - On any error, log it and return { error: "Something went wrong. Please try again." }

       The server action calls the shared handleMagicLinkRequest helper, keeping logic DRY between the API route and server action.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - All four route files export the correct HTTP method handlers (POST, POST, POST, GET)
    - Request route uses Zod validation and calls handleMagicLinkRequest
    - Verify route uses Zod validation for token input
    - Request route calls buildSecurityContext for IP/UA extraction
    - Verify route logs magic_link_verified and session_created events
    - Verify route marks token as used BEFORE creating session
    - Verify route sets session cookie via createSession
    - Logout route clears session from DB and cookie, logs logout event
    - Me route returns user data or 401 (no redirect)
    - Server action uses handleMagicLinkRequest (shared logic, not duplicated)
    - src/actions/auth.ts has 'use server' directive
    - src/actions/auth.ts exports requestMagicLink with correct signature (prevState, formData) -> Promise
  </verify>
  <done>
    All four API routes and the server action compile and implement the complete magic link flow with structured security logging. Request route delegates to shared helper. Verify route handles full token-to-session lifecycle with audit events. Logout destroys sessions with logging. Server action shares logic with API route via handleMagicLinkRequest.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes across all new files
2. Four API routes exist at correct paths under src/app/api/auth/
3. Server action has 'use server' directive and useActionState-compatible signature
4. Email template constructs correct magic link URL (APP_URL + /auth/verify?token=...)
5. Request flow: validate email -> handleMagicLinkRequest (find/create user -> check rate limit -> generate token -> store hash -> send email -> log event) -> return success
6. Verify flow: hash token -> find in DB -> check expiry -> mark used -> create session -> set cookie -> log events -> return redirect
7. No raw tokens stored in database (only SHA-256 hashes)
8. Security events logged for: magic_link_requested, magic_link_verified, magic_link_expired, magic_link_invalid, session_created, logout
9. Server action and API route share logic via handleMagicLinkRequest (no duplication)
</verification>

<success_criteria>
- Magic link request endpoint stores hashed tokens and sends emails
- Magic link verify endpoint validates tokens, creates sessions, sets cookies
- Logout endpoint destroys session in DB and clears cookie
- Me endpoint returns user data or 401
- Server action works with useActionState (prevState, formData signature)
- Rate limiting returns 429 after 5 requests per email per hour
- Email enumeration prevented (always returns success message)
- Auto-creates candidate users on first login attempt
- All auth events produce structured security log entries matching spec format
- No duplicated business logic between server action and API route
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-auth/01-03-SUMMARY.md`
</output>
