---
phase: 01-foundation-and-auth
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/app/api/auth/magic-link/request/route.ts
  - src/app/api/auth/magic-link/verify/route.ts
  - src/app/api/auth/logout/route.ts
  - src/app/api/auth/me/route.ts
  - src/actions/auth.ts
  - src/lib/email/magic-link-email.tsx
autonomous: true
user_setup:
  - service: resend
    why: "Transactional email for magic link delivery"
    env_vars:
      - name: RESEND_API_KEY
        source: "Resend Dashboard -> API Keys -> Create API Key"
      - name: EMAIL_FROM
        source: "Must be a verified domain/email in Resend. For testing: use onboarding@resend.dev"
    dashboard_config:
      - task: "Create a Resend account and verify your sending domain"
        location: "https://resend.com -> Sign up -> Domains -> Add Domain"

must_haves:
  truths:
    - "POST /api/auth/magic-link/request creates a token, stores its hash, and sends an email"
    - "POST /api/auth/magic-link/request always returns success (prevents email enumeration)"
    - "POST /api/auth/magic-link/request respects rate limiting (5 per email per hour)"
    - "POST /api/auth/magic-link/verify validates the token hash, creates a session, and sets a cookie"
    - "POST /api/auth/magic-link/verify rejects expired tokens with a clear error message"
    - "POST /api/auth/magic-link/verify rejects already-used tokens with a clear error message"
    - "POST /api/auth/logout destroys the session cookie and invalidates the DB session"
    - "GET /api/auth/me returns current user data or 401"
    - "Server action requestMagicLink validates email and returns structured state"
  artifacts:
    - path: "src/app/api/auth/magic-link/request/route.ts"
      provides: "POST handler for magic link requests"
      exports: ["POST"]
    - path: "src/app/api/auth/magic-link/verify/route.ts"
      provides: "POST handler for magic link verification"
      exports: ["POST"]
    - path: "src/app/api/auth/logout/route.ts"
      provides: "POST handler for logout"
      exports: ["POST"]
    - path: "src/app/api/auth/me/route.ts"
      provides: "GET handler for current user"
      exports: ["GET"]
    - path: "src/actions/auth.ts"
      provides: "Server action for magic link form"
      exports: ["requestMagicLink"]
    - path: "src/lib/email/magic-link-email.tsx"
      provides: "Email sending function"
      exports: ["sendMagicLinkEmail"]
  key_links:
    - from: "src/app/api/auth/magic-link/request/route.ts"
      to: "src/lib/auth/magic-link.ts"
      via: "generateToken import"
      pattern: "import.*generateToken.*magic-link"
    - from: "src/app/api/auth/magic-link/request/route.ts"
      to: "src/lib/auth/rate-limit.ts"
      via: "checkRateLimit import"
      pattern: "import.*checkRateLimit.*rate-limit"
    - from: "src/app/api/auth/magic-link/request/route.ts"
      to: "src/lib/email/magic-link-email.tsx"
      via: "sendMagicLinkEmail import"
      pattern: "import.*sendMagicLinkEmail"
    - from: "src/app/api/auth/magic-link/verify/route.ts"
      to: "src/lib/auth/session.ts"
      via: "createSession import"
      pattern: "import.*createSession.*session"
    - from: "src/actions/auth.ts"
      to: "src/app/api/auth/magic-link/request/route.ts"
      via: "internal fetch or shared logic"
      pattern: "(fetch|generateToken|sendMagicLinkEmail)"
---

<objective>
Implement the auth API routes, server action, and email sending -- the complete backend for the magic link flow.

Purpose: These routes are the server-side half of authentication. They handle token lifecycle (create, verify, invalidate), session management (create, destroy, read), and email delivery. The server action provides the form handler that the login UI will call.

Output: Four API routes, one server action, and one email function that together implement the full magic link authentication flow.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-and-auth/01-RESEARCH.md
@01-magic-link-auth.md

Depends on Plan 01-02 artifacts:
- src/lib/auth/session.ts (encrypt, decrypt, createSession, deleteSession)
- src/lib/auth/magic-link.ts (generateToken, hashToken)
- src/lib/auth/rate-limit.ts (checkRateLimit)
- src/lib/auth/constants.ts (AUTH_CONSTANTS)
- src/lib/dal.ts (verifySession, getUser)
- src/lib/db/schema.ts (users, magicLinkTokens, sessions)
- src/lib/db/index.ts (db)

Key design decisions:
- Always return success on magic link request (prevent email enumeration)
- Auto-create users on first magic link request (default role: candidate)
- Token stored as SHA-256 hash only (never store raw token)
- Rate limit by userId, checked via DB query
- Verify endpoint is POST only (not GET -- email prefetch protection)
- Session created in DB + encrypted cookie set
- Use Zod for input validation
- Use useActionState-compatible server action signature
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth API routes (request, verify, logout, me)</name>
  <files>
    src/app/api/auth/magic-link/request/route.ts
    src/app/api/auth/magic-link/verify/route.ts
    src/app/api/auth/logout/route.ts
    src/app/api/auth/me/route.ts
  </files>
  <action>
    1. Create `src/app/api/auth/magic-link/request/route.ts`:

       POST handler that:
       a. Parses and validates body with Zod: { email: string (valid email) }
       b. Normalizes email to lowercase and trims whitespace
       c. Looks up user by email in users table
       d. If user not found: auto-create user with role='candidate', emailVerified=false
       e. If user found but is not active (isActive=false): still return success (no enumeration)
       f. Check rate limit via checkRateLimit(userId)
       g. If rate limited: return 429 with { error: "Too many requests. Please try again later." }
       h. Generate token via generateToken()
       i. Insert into magicLinkTokens: userId, tokenHash, expiresAt (now + 10 min), ipAddress (from headers), userAgent (from headers)
       j. Send email via sendMagicLinkEmail(email, token) -- the raw token goes in the email, NOT the hash
       k. Return 200 { success: true, message: "If this email is registered, a login link has been sent." }
       l. Wrap everything in try/catch. On error, log it and return 500.

       IMPORTANT: The response message is deliberately vague to prevent email enumeration. Even though we auto-create users, we should not reveal whether the email was new or existing.

    2. Create `src/app/api/auth/magic-link/verify/route.ts`:

       POST handler that:
       a. Parses body with Zod: { token: string }
       b. Hash the token via hashToken(token)
       c. Query magicLinkTokens: find by tokenHash WHERE usedAt IS NULL
       d. If not found: return 401 { error: "Invalid or already used token." }
       e. If found but expiresAt < now: return 401 { error: "This link has expired. Please request a new one." }
       f. Mark token as used: UPDATE usedAt = NOW()
       g. Look up the user by userId from the token record
       h. Update user: emailVerified = true, lastLoginAt = NOW()
       i. Create a session record in sessions table: userId, tokenHash (new session token hash using generateToken), expiresAt (now + 7 days), ipAddress, userAgent
       j. Call createSession(session.id, user.id, user.role) to set the encrypted cookie
       k. Determine redirect path: use token.redirectPath if set, otherwise default based on role (admin -> /admin, employer -> /employer, candidate -> /candidate)
       l. Return 200 { success: true, redirectTo: redirectPath }

       IMPORTANT: Steps f through j should ideally be atomic. Since we're using neon-http (no interactive transactions), do them sequentially. The usedAt update happens first to prevent race conditions with concurrent verify attempts.

    3. Create `src/app/api/auth/logout/route.ts`:

       POST handler that:
       a. Read and decrypt the session cookie
       b. If valid session: delete session record from sessions table WHERE id = sessionId
       c. Call deleteSession() to clear the cookie
       d. Return 200 { success: true }

    4. Create `src/app/api/auth/me/route.ts`:

       GET handler that:
       a. Read and decrypt the session cookie
       b. If no valid session: return 401 { error: "Not authenticated" }
       c. Query user by userId from session payload
       d. If no user found: return 401 { error: "Not authenticated" }
       e. Return 200 { user: { id, email, role, emailVerified } }

       NOTE: This does NOT use the DAL (which redirects on failure). This is an API route that should return JSON errors, not redirect.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - All four route files export the correct HTTP method handlers (POST, POST, POST, GET)
    - Request route uses Zod validation for email input
    - Verify route uses Zod validation for token input
    - Request route calls checkRateLimit before generating token
    - Request route calls sendMagicLinkEmail
    - Verify route marks token as used BEFORE creating session
    - Verify route sets session cookie via createSession
    - Logout route clears session from DB and cookie
    - Me route returns user data or 401 (no redirect)
  </verify>
  <done>
    All four API routes compile and implement the complete magic link token lifecycle. Request creates tokens with rate limiting. Verify consumes tokens and creates sessions. Logout destroys sessions. Me returns current user.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create server action and email template</name>
  <files>
    src/actions/auth.ts
    src/lib/email/magic-link-email.tsx
  </files>
  <action>
    1. Create `src/lib/email/magic-link-email.tsx`:

       Import Resend from 'resend'.

       Export async function `sendMagicLinkEmail(email: string, token: string): Promise<void>`:
       - Construct magic link URL: `${process.env.APP_URL}/auth/verify?token=${token}`
       - Initialize Resend client with process.env.RESEND_API_KEY
       - Send email with:
         - from: `${process.env.APP_NAME} <${process.env.EMAIL_FROM}>`
         - to: [email]
         - subject: `Sign in to ${process.env.APP_NAME}`
         - html: Professional template with:
           - Heading: "Sign in to [App Name]"
           - Body: "Click the button below to sign in. This link expires in 10 minutes."
           - CTA button: Styled link to magic link URL with text "Sign In"
           - Footer: "If you didn't request this email, you can safely ignore it."
           - Security notes: "This link can only be used once" and "It expires in 10 minutes"
       - On error, throw with descriptive message

       NOTE: Use inline HTML for the email template. We can upgrade to @react-email/components later if needed, but inline HTML is simpler and works reliably across email clients.

    2. Create `src/actions/auth.ts`:

       Add 'use server' directive at top.

       Import Zod for validation.
       Import db, users table, magicLinkTokens table.
       Import generateToken, hashToken from auth/magic-link.
       Import checkRateLimit from auth/rate-limit.
       Import sendMagicLinkEmail from email.
       Import AUTH_CONSTANTS from auth/constants.

       Define and export the MagicLinkState type:
       ```
       type MagicLinkState = {
         success?: boolean
         error?: string
       } | undefined
       ```

       Define RequestMagicLinkSchema with Zod:
       - email: z.string().email('Please enter a valid email address')

       Export async function `requestMagicLink(prevState: MagicLinkState, formData: FormData): Promise<MagicLinkState>`:
       - Extract and validate email from formData
       - If validation fails, return { error: fieldError }
       - Normalize email (lowercase, trim)
       - Look up user by email. If not found, create with role='candidate'
       - Check rate limit. If limited, return { error: "Too many login attempts. Please try again later." }
       - Generate token, store hash in DB with 10-min expiry
       - Send email via sendMagicLinkEmail
       - Return { success: true }
       - On any error, log it and return { error: "Something went wrong. Please try again." }

       This server action has the same logic as the API route but formatted for useActionState compatibility (prevState, formData signature). The API route exists for programmatic access; the server action is what the form UI calls.

       DESIGN DECISION: The server action duplicates some logic from the API route rather than calling the API route internally. This avoids a localhost fetch and is the idiomatic Next.js pattern -- server actions call the database directly. If you want to DRY this up, you could extract shared logic into a helper function in a lib file, but for now the duplication is acceptable for clarity.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - src/actions/auth.ts has 'use server' directive
    - src/actions/auth.ts exports requestMagicLink with correct signature (prevState, formData) -> Promise
    - src/actions/auth.ts exports MagicLinkState type
    - src/lib/email/magic-link-email.tsx exports sendMagicLinkEmail
    - Email template includes magic link URL with token parameter
    - Server action uses Zod validation
    - Server action handles rate limiting
    - Server action auto-creates users when email not found
  </verify>
  <done>
    Server action provides useActionState-compatible form handler for the login form. Email function sends branded magic link emails via Resend. Together with the API routes from Task 1, the complete server-side auth flow is implemented.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes across all new files
2. Four API routes exist at correct paths under src/app/api/auth/
3. Server action has 'use server' directive and useActionState-compatible signature
4. Email template constructs correct magic link URL (APP_URL + /auth/verify?token=...)
5. Request flow: validate email -> find/create user -> check rate limit -> generate token -> store hash -> send email -> return success
6. Verify flow: hash token -> find in DB -> check expiry -> mark used -> create session -> set cookie -> return redirect
7. No raw tokens stored in database (only SHA-256 hashes)
</verification>

<success_criteria>
- Magic link request endpoint stores hashed tokens and sends emails
- Magic link verify endpoint validates tokens, creates sessions, sets cookies
- Logout endpoint destroys session in DB and clears cookie
- Me endpoint returns user data or 401
- Server action works with useActionState (prevState, formData signature)
- Rate limiting returns 429 after 5 requests per email per hour
- Email enumeration prevented (always returns success message)
- Auto-creates candidate users on first login attempt
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-auth/01-03-SUMMARY.md`
</output>
