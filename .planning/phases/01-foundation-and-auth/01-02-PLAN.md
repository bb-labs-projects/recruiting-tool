---
phase: 01-foundation-and-auth
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/auth/session.ts
  - src/lib/auth/magic-link.ts
  - src/lib/auth/rate-limit.ts
  - src/lib/auth/constants.ts
  - src/lib/dal.ts
  - src/proxy.ts
autonomous: true

must_haves:
  truths:
    - "Session can be created, encrypted into a cookie, and decrypted back"
    - "Magic link tokens are generated as random 32-byte hex and hashed with SHA-256"
    - "Rate limiting counts recent tokens per email from the database"
    - "Proxy redirects unauthenticated users to /login"
    - "Proxy redirects authenticated users away from public routes to their role-based area"
    - "Proxy blocks non-admin users from /admin routes"
    - "DAL verifies session exists in database and is not expired"
  artifacts:
    - path: "src/lib/auth/session.ts"
      provides: "encrypt, decrypt, createSession, deleteSession functions"
      exports: ["encrypt", "decrypt", "createSession", "deleteSession"]
    - path: "src/lib/auth/magic-link.ts"
      provides: "Token generation and hashing"
      exports: ["generateToken", "hashToken"]
    - path: "src/lib/auth/rate-limit.ts"
      provides: "Database-backed rate limit check"
      exports: ["checkRateLimit"]
    - path: "src/lib/auth/constants.ts"
      provides: "Auth configuration constants"
      exports: ["AUTH_CONSTANTS"]
    - path: "src/lib/dal.ts"
      provides: "verifySession and getUser with DB checks"
      exports: ["verifySession", "getUser"]
    - path: "src/proxy.ts"
      provides: "Route protection and role-based redirects"
      exports: ["proxy", "config"]
  key_links:
    - from: "src/proxy.ts"
      to: "src/lib/auth/session.ts"
      via: "decrypt import"
      pattern: "import.*decrypt.*session"
    - from: "src/lib/dal.ts"
      to: "src/lib/auth/session.ts"
      via: "decrypt import"
      pattern: "import.*decrypt.*session"
    - from: "src/lib/dal.ts"
      to: "src/lib/db/schema.ts"
      via: "sessions and users table import"
      pattern: "import.*sessions.*schema"
    - from: "src/lib/auth/rate-limit.ts"
      to: "src/lib/db/schema.ts"
      via: "magicLinkTokens table import"
      pattern: "import.*magicLinkTokens.*schema"
---

<objective>
Build the auth infrastructure layer: session management, token utilities, rate limiting, Data Access Layer, and proxy-based route protection.

Purpose: This layer sits between the database schema (Plan 01) and the auth API routes (Plan 03). It provides all the building blocks that API routes and server actions will call. The proxy provides first-line route protection; the DAL provides secure database-backed verification.

Output: Six library files that implement the three-layer defense-in-depth auth pattern from the Next.js 16 official guide.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-and-auth/01-RESEARCH.md
@01-magic-link-auth.md

Key patterns from research:
- Defense-in-depth: proxy (optimistic cookie check) -> DAL (database verification) -> component-level
- proxy.ts exports function named `proxy` (NOT `middleware`) -- Next.js 16 convention
- Session: jose SignJWT/jwtVerify with HS256, HTTP-only cookie, 7-day expiry
- DAL: cache() wraps verifySession for request deduplication, uses `server-only` import
- Rate limit: Database-backed -- COUNT magic_link_tokens WHERE userId matches AND createdAt > 1 hour ago
- DO NOT do DB calls in proxy -- only decrypt cookie (fast)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth library modules (session, magic-link, rate-limit, constants)</name>
  <files>
    src/lib/auth/constants.ts
    src/lib/auth/session.ts
    src/lib/auth/magic-link.ts
    src/lib/auth/rate-limit.ts
  </files>
  <action>
    1. Create `src/lib/auth/constants.ts`:
       Export an AUTH_CONSTANTS object with:
       - MAGIC_LINK_EXPIRY_MINUTES: 10
       - MAGIC_LINK_RATE_LIMIT_PER_HOUR: 5
       - SESSION_EXPIRY_DAYS: 7
       - SESSION_COOKIE_NAME: 'session'
       - TOKEN_BYTE_LENGTH: 32

    2. Create `src/lib/auth/session.ts`:
       - Add `import 'server-only'` at the top (prevents client bundle inclusion)
       - Import SignJWT, jwtVerify from 'jose'
       - Import cookies from 'next/headers'
       - Import AUTH_CONSTANTS from './constants'

       Define SessionPayload interface:
       ```
       { sessionId: string; userId: string; role: string; expiresAt: Date }
       ```

       Implement:
       - `encrypt(payload: SessionPayload): Promise<string>` -- SignJWT with HS256, 7d expiration
       - `decrypt(session: string | undefined): Promise<SessionPayload | null>` -- jwtVerify, returns null on error (not throw)
       - `createSession(sessionId: string, userId: string, role: string): Promise<void>` -- encrypts payload, sets HTTP-only cookie with: httpOnly=true, secure=(NODE_ENV==='production'), sameSite='strict', path='/', expires=7 days
       - `deleteSession(): Promise<void>` -- deletes the session cookie

       Use `process.env.SESSION_SECRET` encoded with TextEncoder for the signing key.

    3. Create `src/lib/auth/magic-link.ts`:
       - Add `import 'server-only'`
       - Import randomBytes, createHash from 'crypto'

       Implement:
       - `generateToken(): { token: string; tokenHash: string }` -- randomBytes(32).toString('hex'), SHA-256 hash
       - `hashToken(token: string): string` -- SHA-256 hash of input

    4. Create `src/lib/auth/rate-limit.ts`:
       - Add `import 'server-only'`
       - Import db from '@/lib/db'
       - Import magicLinkTokens from '@/lib/db/schema'
       - Import sql, count, and, gte, eq from 'drizzle-orm'
       - Import AUTH_CONSTANTS from './constants'

       Implement `checkRateLimit(userId: string): Promise<{ allowed: boolean; remaining: number }>`:
       - Query: SELECT COUNT(*) FROM magic_link_tokens WHERE user_id = userId AND created_at >= NOW() - 1 hour
       - Compare count against AUTH_CONSTANTS.MAGIC_LINK_RATE_LIMIT_PER_HOUR
       - Return { allowed: count < limit, remaining: limit - count }

       This is database-backed (not in-memory) because Vercel serverless functions are ephemeral and in-memory state is lost on cold start.
  </action>
  <verify>
    - `npx tsc --noEmit` passes with no type errors
    - Each file has `import 'server-only'` (except constants.ts which is shared)
    - session.ts exports encrypt, decrypt, createSession, deleteSession
    - magic-link.ts exports generateToken, hashToken
    - rate-limit.ts exports checkRateLimit
    - constants.ts exports AUTH_CONSTANTS
  </verify>
  <done>
    All four auth library modules compile. Session management uses jose with HS256. Magic link uses crypto.randomBytes(32) with SHA-256 hashing. Rate limiting queries the database. Constants are centralized.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Data Access Layer and proxy route protection</name>
  <files>
    src/lib/dal.ts
    src/proxy.ts
  </files>
  <action>
    1. Create `src/lib/dal.ts`:
       - Add `import 'server-only'`
       - Import cache from 'react'
       - Import cookies from 'next/headers'
       - Import redirect from 'next/navigation'
       - Import decrypt from '@/lib/auth/session'
       - Import db from '@/lib/db'
       - Import users, sessions from '@/lib/db/schema'
       - Import eq, and, gt from 'drizzle-orm'

       Implement `verifySession` (wrapped in cache()):
       - Read 'session' cookie
       - Decrypt with decrypt()
       - If no payload or no sessionId, redirect('/login')
       - Query DB: SELECT from sessions WHERE id = payload.sessionId AND expiresAt > NOW()
       - If no session found, redirect('/login')
       - Return { userId: session.userId, sessionId: session.id }

       Implement `getUser` (wrapped in cache()):
       - Call verifySession() first
       - Query DB: SELECT id, email, role, emailVerified FROM users WHERE id = session.userId
       - Return user or null

    2. Create `src/proxy.ts` (NOT middleware.ts -- Next.js 16 convention):
       - Import NextResponse, NextRequest from 'next/server'
       - Import decrypt from '@/lib/auth/session'

       Define route arrays:
       - publicRoutes = ['/login', '/auth/verify']

       Export async function `proxy(request: NextRequest)`:
       - Get pathname from request.nextUrl
       - Check if route is public
       - Decrypt session cookie (fast, no DB call)

       Logic:
       a. If route is NOT public AND no valid session -> redirect to /login
       b. If route IS public AND valid session -> redirect based on role:
          - admin -> /admin
          - employer -> /employer
          - candidate -> /candidate
       c. If path starts with '/admin' AND role !== 'admin' -> redirect to /login
       d. If path starts with '/employer' AND role !== 'employer' AND role !== 'admin' -> redirect to appropriate area
       e. If path starts with '/candidate' AND role !== 'candidate' AND role !== 'admin' -> redirect to appropriate area
       f. Otherwise, NextResponse.next()

       Export config with matcher:
       ```
       matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)']
       ```

       IMPORTANT: The proxy does NOT make database calls. It only reads and decrypts the cookie. This keeps it fast since proxy runs on every matched route including prefetches. The DAL handles the secure database verification in server components and server actions.

       IMPORTANT: The exported function must be named `proxy` not `middleware` -- this is the Next.js 16 convention per research.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `src/proxy.ts` exports a function named `proxy` (NOT `middleware`)
    - `src/proxy.ts` exports a `config` object with matcher
    - `src/proxy.ts` does NOT import from '@/lib/db' (no database calls in proxy)
    - `src/lib/dal.ts` has `import 'server-only'` at top
    - `src/lib/dal.ts` exports verifySession and getUser
    - Both verifySession and getUser are wrapped in cache()
  </verify>
  <done>
    DAL provides secure database-backed session verification with request deduplication via cache(). Proxy provides fast cookie-based route protection with role-based redirects. Neither relies on the other -- they are independent layers in the defense-in-depth pattern.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors across all new files
2. proxy.ts has NO database imports (optimistic only)
3. dal.ts has `import 'server-only'` (cannot be imported in client components)
4. session.ts, magic-link.ts, rate-limit.ts all have `import 'server-only'`
5. All auth constants are centralized in constants.ts (no magic numbers)
6. Rate limiting uses database query, not in-memory Map
</verification>

<success_criteria>
- Session encrypt/decrypt round-trips a SessionPayload correctly
- Magic link generateToken returns a 64-char hex token and 64-char hex hash
- Rate limit queries magic_link_tokens table with time window
- Proxy redirects unauthenticated users to /login
- Proxy redirects authenticated users on public routes to role-based dashboard
- Proxy blocks non-admin from /admin routes
- DAL verifies sessions against the database
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-auth/01-02-SUMMARY.md`
</output>
