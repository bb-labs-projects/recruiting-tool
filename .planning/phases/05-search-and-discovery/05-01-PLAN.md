---
phase: 05-search-and-discovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/db/relations.ts
  - drizzle/0001_enable_pg_trgm.sql
  - src/lib/dal/employer-profiles.ts
  - src/lib/dal/employer-saved.ts
autonomous: true

must_haves:
  truths:
    - "Employer browse query filters profiles by specialization via EXISTS subquery on junction table"
    - "Employer browse query filters profiles by technical domain via EXISTS subquery on junction table"
    - "Employer browse query filters profiles by patent bar status (USPTO bar admission)"
    - "Employer browse query filters profiles by jurisdiction/location via ILIKE on bar_admissions"
    - "Free-text search matches across specialization names, technical domain names, jurisdictions, and education fields -- NEVER against PII columns"
    - "savedProfiles table allows employers to bookmark candidate profiles"
    - "Count query uses identical WHERE conditions as results query"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "savedProfiles table definition"
      contains: "savedProfiles"
    - path: "src/lib/db/relations.ts"
      provides: "savedProfiles relations"
      contains: "savedProfilesRelations"
    - path: "drizzle/0001_enable_pg_trgm.sql"
      provides: "pg_trgm extension and GIN indexes"
      contains: "CREATE EXTENSION IF NOT EXISTS pg_trgm"
    - path: "src/lib/dal/employer-profiles.ts"
      provides: "Rewritten getAnonymizedProfiles with dynamic filtering"
      contains: "exists"
    - path: "src/lib/dal/employer-saved.ts"
      provides: "Saved profile query functions"
      exports: ["getSavedProfileIds", "getSavedProfiles"]
  key_links:
    - from: "src/lib/dal/employer-profiles.ts"
      to: "src/lib/db/schema.ts"
      via: "EXISTS subqueries on profileSpecializations, profileTechnicalDomains, barAdmissions, education"
      pattern: "exists.*select.*from.*profileSpecializations"
    - from: "src/lib/dal/employer-saved.ts"
      to: "src/lib/db/schema.ts"
      via: "queries on savedProfiles table"
      pattern: "savedProfiles"
---

<objective>
Build the backend foundation for Phase 5 search and discovery: extend the database schema with a saved_profiles table, create a custom migration to enable pg_trgm and GIN indexes, rewrite the employer DAL to support dynamic multi-filter queries with EXISTS subqueries, and add a saved profiles DAL module.

Purpose: All frontend search, filter, and save features depend on this data layer. The key technical challenge is transitioning getAnonymizedProfiles from Drizzle's relational query API to the select/join builder while maintaining the anonymization column-inclusion pattern.

Output: Working DAL that accepts multi-dimensional filter params and returns paginated anonymized profiles, plus schema/migration for saved profiles and trigram search indexes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-search-and-discovery/05-RESEARCH.md

Key source files:
@src/lib/db/schema.ts
@src/lib/db/relations.ts
@src/lib/dal/employer-profiles.ts
@src/lib/anonymize.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema extension and pg_trgm migration</name>
  <files>
    src/lib/db/schema.ts
    src/lib/db/relations.ts
    drizzle/0001_enable_pg_trgm.sql
  </files>
  <action>
    1. In `src/lib/db/schema.ts`, add the `savedProfiles` table AFTER the `employerProfiles` table:
       ```typescript
       export const savedProfiles = pgTable('saved_profiles', {
         employerUserId: uuid('employer_user_id')
           .notNull()
           .references(() => users.id, { onDelete: 'cascade' }),
         profileId: uuid('profile_id')
           .notNull()
           .references(() => profiles.id, { onDelete: 'cascade' }),
         savedAt: timestamp('saved_at', { withTimezone: true }).defaultNow().notNull(),
       }, (table) => [
         primaryKey({ columns: [table.employerUserId, table.profileId] }),
         index('saved_profiles_employer_idx').on(table.employerUserId),
         index('saved_profiles_profile_idx').on(table.profileId),
       ])
       ```

    2. In `src/lib/db/relations.ts`:
       - Import `savedProfiles` from schema
       - Add `savedProfiles` relation to `profilesRelations` (add `many(savedProfiles)` to the existing relation)
       - Add `savedProfilesRelations`:
         ```typescript
         export const savedProfilesRelations = relations(savedProfiles, ({ one }) => ({
           user: one(users, {
             fields: [savedProfiles.employerUserId],
             references: [users.id],
           }),
           profile: one(profiles, {
             fields: [savedProfiles.profileId],
             references: [profiles.id],
           }),
         }))
         ```
       - Update `usersRelations` to include `savedProfiles: many(savedProfiles)` (change from `({ one })` to `({ one, many })`)

    3. Create `drizzle/0001_enable_pg_trgm.sql` as a custom migration:
       ```sql
       CREATE EXTENSION IF NOT EXISTS pg_trgm;

       -- GIN indexes for ILIKE search acceleration on non-PII text fields
       CREATE INDEX IF NOT EXISTS idx_specializations_name_trgm
         ON specializations USING GIN (name gin_trgm_ops);
       CREATE INDEX IF NOT EXISTS idx_technical_domains_name_trgm
         ON technical_domains USING GIN (name gin_trgm_ops);
       CREATE INDEX IF NOT EXISTS idx_bar_admissions_jurisdiction_trgm
         ON bar_admissions USING GIN (jurisdiction gin_trgm_ops);
       CREATE INDEX IF NOT EXISTS idx_education_institution_trgm
         ON education USING GIN (institution gin_trgm_ops);
       CREATE INDEX IF NOT EXISTS idx_education_field_trgm
         ON education USING GIN (field gin_trgm_ops);
       ```
       Note: This is a CUSTOM migration file (not generated by drizzle-kit). It will be run manually by the user with `npx drizzle-kit push` or directly against the database. Include a comment at the top: `-- Custom migration: enable pg_trgm and create GIN indexes for search`.

    IMPORTANT: The `primaryKey` import should already exist in schema.ts. Verify it is in the import list; add if missing.
  </action>
  <verify>
    - `npx tsc --noEmit` passes (no TypeScript errors in schema or relations)
    - The savedProfiles table has composite primary key on (employerUserId, profileId)
    - The migration SQL file exists at drizzle/0001_enable_pg_trgm.sql
  </verify>
  <done>
    savedProfiles table defined in schema with proper FK references, relations wired for both directions (user->saves, profile->saves), and pg_trgm migration SQL ready to apply.
  </done>
</task>

<task type="auto">
  <name>Task 2: Rewrite employer DAL with dynamic filtering and add saved profiles DAL</name>
  <files>
    src/lib/dal/employer-profiles.ts
    src/lib/dal/employer-saved.ts
  </files>
  <action>
    1. REWRITE `src/lib/dal/employer-profiles.ts` using the two-query strategy from research:

       **SearchFilters type:**
       ```typescript
       export type SearchFilters = {
         search?: string
         specializations?: string[]
         technicalDomains?: string[]
         patentBar?: boolean
         experienceRange?: string
         location?: string
         page?: number
         pageSize?: number
       }
       ```

       **escapeIlike helper** (escape %, _, \ before wrapping in wildcards):
       ```typescript
       function escapeIlike(input: string): string {
         return input.replace(/[%_\\]/g, '\\$&')
       }
       ```

       **buildFilterConditions function** that returns `SQL[]`:
       - Always include `eq(profiles.status, 'active')` as first condition
       - Specialization filter: `exists()` subquery joining `profileSpecializations` to `specializations`, using `inArray(specializations.name, filters.specializations)`
       - Technical domain filter: `exists()` subquery joining `profileTechnicalDomains` to `technicalDomains`, using `inArray(technicalDomains.name, filters.technicalDomains)`
       - Patent bar filter: `exists()` subquery on `barAdmissions` where `ilike(barAdmissions.jurisdiction, '%USPTO%')`
       - Location filter: `exists()` subquery on `barAdmissions` where `ilike(barAdmissions.jurisdiction, '%${escapeIlike(location)}%')`
       - Free-text search: Raw SQL with OR across 4 EXISTS subqueries searching specialization names, technical domain names, bar admission jurisdictions, and education institution/degree/field. NEVER search against profiles.name, profiles.email, profiles.phone, or workHistory.employer.
       - Experience range filter: For now, skip SQL-level filtering -- filter post-query by computing experience from work history (same as current `bucketExperienceYears`). This keeps the query simple and is fast enough for <1000 profiles. Apply before pagination offset to ensure correct counts.

       **Rewritten getAnonymizedProfiles** using two-query strategy:
       - Step 1 (filter query): `db.select({ id: profiles.id }).from(profiles).where(and(...conditions))` -- get all matching IDs (no limit yet, because experience range filtering happens post-query)
       - Step 1b (experience range post-filter): If experienceRange is set, load work history for matched IDs, compute bucketExperienceYears for each, filter out non-matching profiles. This is necessary because experience is computed from work_history dates, not stored as a column.
       - Step 1c (pagination): Apply offset/limit to the filtered ID list in JS. Set total = filtered list length.
       - Step 2 (data loading): `db.query.profiles.findMany` with `inArray(profiles.id, paginatedIds)` using column inclusion mode (same pattern as current). Load all related data (specializations, technicalDomains, education, barAdmissions, workHistory).
       - Step 3 (DTO transform): Map to `AnonymizedProfileDTO[]` using same transform as current code (bucketExperienceYears, anonymizeWorkHistory).
       - Return `{ profiles, total }`

       **Keep getAnonymizedProfileById unchanged** -- it doesn't need filter support.

       Import requirements: `eq, and, exists, ilike, inArray, count, desc, sql` from `drizzle-orm`. Import all needed schema tables. Keep `import 'server-only'` and `cache` wrapper.

    2. CREATE `src/lib/dal/employer-saved.ts`:
       ```typescript
       import 'server-only'
       import { cache } from 'react'
       import { db } from '@/lib/db'
       import { savedProfiles } from '@/lib/db/schema'
       import { eq, and, inArray } from 'drizzle-orm'
       ```

       **getSavedProfileIds(employerUserId: string, profileIds: string[]): Promise<Set<string>>**
       - If profileIds is empty, return empty Set
       - Query savedProfiles where employerUserId matches AND profileId in profileIds
       - Return Set of saved profile IDs
       - Wrap in `cache()`

       **getSavedProfiles(employerUserId: string): Promise<string[]>**
       - Query all savedProfiles for the employer, ordered by savedAt desc
       - Return array of profile IDs
       - Wrap in `cache()`

       **isProfileSaved(employerUserId: string, profileId: string): Promise<boolean>**
       - Query savedProfiles with both conditions, limit 1
       - Return boolean
       - Wrap in `cache()`

    CRITICAL ANTI-PATTERNS TO AVOID:
    - Do NOT use `db.query.profiles.findMany` with nested `where` on `with` relations for filtering -- it only filters children, not parents
    - Do NOT search against PII columns (profiles.name, profiles.email, profiles.phone, workHistory.employer)
    - Do NOT use separate WHERE conditions for count vs results query -- extract shared conditions variable
    - Escape user input in ILIKE patterns using escapeIlike helper
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `employer-profiles.ts` exports: SearchFilters type, getAnonymizedProfiles (with SearchFilters param), getAnonymizedProfileById (unchanged), AnonymizedProfileDTO type
    - `employer-saved.ts` exports: getSavedProfileIds, getSavedProfiles, isProfileSaved
    - No PII column names (name, email, phone) appear in any search/filter condition in employer-profiles.ts
    - The `escapeIlike` function exists and handles %, _, and \ characters
  </verify>
  <done>
    getAnonymizedProfiles accepts multi-dimensional SearchFilters and returns correctly filtered, paginated, anonymized profiles. Saved profiles DAL provides batch lookup (for browse page), full list (for saved page), and single check (for detail page). All functions use server-only and cache wrappers.
  </done>
</task>

</tasks>

<verification>
- TypeScript compilation passes: `npx tsc --noEmit`
- Schema has savedProfiles table with composite PK and proper FK references
- Relations include savedProfiles in both directions
- pg_trgm migration SQL file exists with GIN indexes on non-PII text columns
- getAnonymizedProfiles accepts SearchFilters with specializations[], technicalDomains[], patentBar, location, search, experienceRange
- Free-text search ONLY matches non-PII fields
- Count and results use identical filter conditions
- employer-saved.ts exports getSavedProfileIds, getSavedProfiles, isProfileSaved
</verification>

<success_criteria>
1. `npx tsc --noEmit` passes with zero errors
2. getAnonymizedProfiles({ specializations: ['Patent Prosecution'] }) would return only profiles with that specialization (verified by code inspection of EXISTS subquery)
3. Free-text search conditions reference ONLY: specializations.name, technicalDomains.name, barAdmissions.jurisdiction, education.institution, education.degree, education.field
4. savedProfiles schema has composite PK on (employerUserId, profileId) preventing duplicates
5. All DAL functions have 'server-only' import and cache() wrapper
</success_criteria>

<output>
After completion, create `.planning/phases/05-search-and-discovery/05-01-SUMMARY.md`
</output>
