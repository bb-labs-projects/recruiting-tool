---
phase: 07-candidate-self-service
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/app/api/candidate/cv/upload/route.ts
  - src/app/api/candidate/cv/parse/route.ts
  - src/app/api/candidate/cv/status/route.ts
  - src/actions/candidate-profiles.ts
autonomous: true

must_haves:
  truths:
    - "Candidate can upload a PDF CV via their own API route (not the admin route)"
    - "Uploaded CV triggers parsing via parseSingleCv and sets userId on resulting profile"
    - "Candidate can poll for their upload/parse status"
    - "Candidate can edit their own profile fields with ownership verification"
    - "Editing an active profile changes status back to pending_review"
    - "Candidate can submit their profile for review"
  artifacts:
    - path: "src/app/api/candidate/cv/upload/route.ts"
      provides: "Candidate blob upload endpoint (POST for token, PUT for record creation)"
      exports: ["POST", "PUT"]
    - path: "src/app/api/candidate/cv/parse/route.ts"
      provides: "Candidate parse trigger that calls parseSingleCv and sets userId on profile"
      exports: ["POST"]
    - path: "src/app/api/candidate/cv/status/route.ts"
      provides: "Candidate upload status polling endpoint"
      exports: ["GET"]
    - path: "src/actions/candidate-profiles.ts"
      provides: "Server actions for candidate profile editing with ownership checks"
      exports: ["updateCandidateProfileField", "updateCandidateEducation", "updateCandidateWorkHistory", "updateCandidateBarAdmission", "submitProfileForReview"]
  key_links:
    - from: "src/app/api/candidate/cv/parse/route.ts"
      to: "src/lib/cv-parser/parse.ts"
      via: "calls parseSingleCv then sets userId on resulting profile"
      pattern: "parseSingleCv"
    - from: "src/actions/candidate-profiles.ts"
      to: "src/lib/dal.ts"
      via: "getUser() for auth, then ownership check via profile.userId"
      pattern: "getUser.*profiles\\.userId"
    - from: "src/app/api/candidate/cv/parse/route.ts"
      to: "src/lib/dal/candidate-profiles.ts"
      via: "calls checkDuplicateProfiles after parse completes"
      pattern: "checkDuplicateProfiles"
---

<objective>
Create all candidate backend: API routes for CV upload/parse/status polling, and server actions for profile editing with ownership authorization.

Purpose: Candidates need their own API routes separate from admin (different auth: getUser + role check instead of requireAdmin). Server actions need ownership verification (profile.userId === user.id). The parse route must set userId on the resulting profile and run duplicate detection. This plan builds all the backend that the candidate UI pages (Plan 04) will consume.

Output: Three API routes (upload, parse, status) and one server actions file with five candidate-specific actions.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-candidate-self-service/07-RESEARCH.md
@src/app/api/admin/cv/upload/route.ts
@src/app/api/admin/cv/parse/route.ts
@src/app/api/admin/cv/status/route.ts
@src/lib/cv-parser/parse.ts
@src/actions/profiles.ts
@src/lib/dal.ts
@src/lib/dal/candidate-profiles.ts
@src/lib/db/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create candidate CV upload, parse, and status API routes</name>
  <files>src/app/api/candidate/cv/upload/route.ts, src/app/api/candidate/cv/parse/route.ts, src/app/api/candidate/cv/status/route.ts</files>
  <action>
    **1. Candidate upload route (`src/app/api/candidate/cv/upload/route.ts`):**

    Adapt from the admin upload route (`src/app/api/admin/cv/upload/route.ts`). Key differences:
    - Auth: Use `getUser()` from `@/lib/dal` + check `user.role === 'candidate'` (NOT `requireAdmin()`)
    - In `onBeforeGenerateToken`: get user, verify role is candidate, return same allowedContentTypes and maximumSizeInBytes as admin
    - The `onUploadCompleted` callback in Vercel Blob runs asynchronously and may not have request context. Follow the same two-step pattern as admin: POST for blob token, PUT for DB record creation.
    - PUT handler: get user via `getUser()`, verify role === 'candidate', check if user already has a profile via `getCandidateProfile(user.id)` from the candidate DAL. If a profile already exists, this is a re-upload -- store the cvUpload record but the parse route will handle profile replacement. Insert into `cvUploads` table with `uploadedBy: user.id`.
    - Return the created record as JSON.

    **2. Candidate parse route (`src/app/api/candidate/cv/parse/route.ts`):**

    Create a POST endpoint. Auth: `getUser()` + role === 'candidate'.
    - Accept `{ cvUploadId }` in request body
    - Verify the cvUpload belongs to this candidate: query cvUploads WHERE id = cvUploadId AND uploadedBy = user.id
    - Set `export const maxDuration = 60` for Vercel function timeout
    - Check if candidate already has a profile via `getCandidateProfile(user.id)`:
      - If existing profile found: delete related data first. Delete from profileSpecializations, profileTechnicalDomains, education, workHistory, barAdmissions WHERE profileId = existing.id. Then delete the profile itself. This ensures clean re-upload.
    - Call `parseSingleCv(cvUploadId)` from `@/lib/cv-parser/parse.ts`
    - If parse succeeds (result.success && result.profileId):
      - Set userId on the new profile: `db.update(profiles).set({ userId: user.id }).where(eq(profiles.id, result.profileId))`
      - Run duplicate detection: call `checkDuplicateProfiles(...)` from candidate DAL. Need to fetch the profile to get name/email first. If duplicates found, update the profile's duplicateNotes with the flags joined by newline.
    - Return the parse result as JSON

    **3. Candidate status route (`src/app/api/candidate/cv/status/route.ts`):**

    Create a GET endpoint. Auth: `getUser()` + role === 'candidate'.
    - Query cvUploads WHERE uploadedBy = user.id, ordered by createdAt DESC
    - Return the uploads as JSON array
    - This mirrors `/api/admin/cv/status` but scoped to the candidate's own uploads

    For all three routes: if auth fails, return 403 `{ error: 'Forbidden' }`. If user is null, return 401 `{ error: 'Unauthorized' }`.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm all three route files compile. Verify each exports the correct HTTP methods (upload: POST + PUT, parse: POST, status: GET).
  </verify>
  <done>
    Three candidate API routes exist: upload (blob upload with candidate auth), parse (triggers parseSingleCv + sets userId + duplicate detection + handles re-upload by deleting old profile), status (polls candidate's upload records). All use getUser() + role check instead of requireAdmin().
  </done>
</task>

<task type="auto">
  <name>Task 2: Create candidate profile server actions with ownership authorization</name>
  <files>src/actions/candidate-profiles.ts</files>
  <action>
    Create `src/actions/candidate-profiles.ts` with `'use server'` directive. This mirrors `src/actions/profiles.ts` but with candidate ownership checks instead of admin checks.

    **Helper function `requireCandidateOwner(profileId: string)`:**
    - Call `getUser()`, verify role === 'candidate'
    - Query profiles WHERE id = profileId AND userId = user.id
    - If no match, throw Error('Unauthorized')
    - Return user object
    - Also check profile status: if profile is 'active', the edit actions should change status to 'pending_review' (re-review trigger)

    **Action 1: `updateCandidateProfileField(formData: FormData)`**
    - Same Zod schema as admin: profileId, fieldName (enum: name, email, phone), value
    - Call requireCandidateOwner(profileId)
    - Update the field + set confidence to 'high' + update updatedAt
    - If profile was 'active', also set status to 'pending_review' (this removes it from search temporarily)
    - revalidatePath('/candidate/profile')

    **Action 2: `updateCandidateEducation(formData: FormData)`**
    - Same schema as admin updateEducation: educationId, profileId, institution, degree, field, year
    - Call requireCandidateOwner(profileId)
    - Update education record (verify it belongs to the profile via AND clause)
    - If profile was 'active', set status to 'pending_review'
    - revalidatePath('/candidate/profile')

    **Action 3: `updateCandidateWorkHistory(formData: FormData)`**
    - Same as admin but with candidate ownership check
    - If profile was 'active', set status to 'pending_review'
    - revalidatePath('/candidate/profile')

    **Action 4: `updateCandidateBarAdmission(formData: FormData)`**
    - Same as admin but with candidate ownership check
    - If profile was 'active', set status to 'pending_review'
    - revalidatePath('/candidate/profile')

    **Action 5: `submitProfileForReview(formData: FormData)`**
    - Accept profileId from formData
    - Call requireCandidateOwner(profileId)
    - Only allow submission if profile status is 'pending_review' or 'rejected' (not 'active')
    - Update profile status to 'pending_review', clear rejectionNotes, update updatedAt
    - revalidatePath('/candidate/profile')
    - revalidatePath('/candidate')

    For the re-review trigger: create a helper `triggerReReviewIfActive(profileId: string)` that checks the current profile status and updates to 'pending_review' if it was 'active'. Call this at the end of each edit action.

    IMPORTANT: Do NOT import or use requireAdmin. Use getUser() directly. Do NOT revalidate admin paths -- only candidate paths.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm the actions file compiles. Verify it exports all five action functions: updateCandidateProfileField, updateCandidateEducation, updateCandidateWorkHistory, updateCandidateBarAdmission, submitProfileForReview.
  </verify>
  <done>
    Candidate server actions file exists with five exported functions. All use ownership-scoped authorization (getUser + profile.userId check). Edit actions trigger re-review if profile was active. submitProfileForReview sets status to pending_review.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- All three API routes exist and export correct HTTP methods
- Candidate upload route uses `getUser()` + role check, NOT `requireAdmin()`
- Parse route calls `parseSingleCv`, sets `userId` on resulting profile, runs duplicate detection
- Parse route handles re-upload by deleting old profile and related data first
- Server actions file exports five functions with ownership authorization
- Edit actions trigger re-review (status -> pending_review) when editing an active profile
</verification>

<success_criteria>
All candidate backend routes and actions compile. Upload route is separate from admin route with candidate-specific auth. Parse route sets userId on profile and runs duplicate detection. Server actions enforce ownership (profile.userId === user.id) and trigger re-review on active profile edits.
</success_criteria>

<output>
After completion, create `.planning/phases/07-candidate-self-service/07-02-SUMMARY.md`
</output>
