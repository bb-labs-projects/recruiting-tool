---
phase: 07-candidate-self-service
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/db/relations.ts
  - drizzle/0002_candidate_profile_ownership.sql
  - src/lib/dal/candidate-profiles.ts
autonomous: true

must_haves:
  truths:
    - "Profiles table has a nullable userId column linking candidates to their profile"
    - "A candidate user can have at most one profile (partial unique index enforced)"
    - "Candidate DAL can query a profile by userId with all related data"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "userId column on profiles table"
      contains: "userId"
    - path: "src/lib/db/relations.ts"
      provides: "User-to-profile bidirectional relation"
      contains: "candidateProfile"
    - path: "drizzle/0002_candidate_profile_ownership.sql"
      provides: "Partial unique index and duplicateNotes column migration"
      contains: "profiles_user_id_unique"
    - path: "src/lib/dal/candidate-profiles.ts"
      provides: "Candidate data access with ownership scoping"
      exports: ["getCandidateProfile", "getCandidateUploads"]
  key_links:
    - from: "src/lib/db/schema.ts"
      to: "src/lib/db/relations.ts"
      via: "profiles.userId referenced in profilesRelations and usersRelations"
      pattern: "profiles\\.userId"
    - from: "src/lib/dal/candidate-profiles.ts"
      to: "src/lib/db/schema.ts"
      via: "queries profiles table filtering by userId"
      pattern: "eq.*profiles\\.userId"
---

<objective>
Add profile-to-user ownership to the database schema and create the candidate data access layer.

Purpose: This is the foundational schema change that enables all candidate self-service features. Currently profiles have no userId column -- they were designed for agency-uploaded CVs with no user ownership. Adding a nullable userId FK to profiles, plus a partial unique index (one profile per user), plus a candidate-specific DAL module gives downstream plans everything they need to build the candidate experience.

Output: Updated schema with userId on profiles, updated relations with bidirectional user-profile link, SQL migration file for partial unique index + duplicateNotes column, and candidate DAL module.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-candidate-self-service/07-RESEARCH.md
@src/lib/db/schema.ts
@src/lib/db/relations.ts
@src/lib/dal/employer-profiles.ts
@src/lib/dal.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add userId and duplicateNotes to profiles schema, update relations, create SQL migration</name>
  <files>src/lib/db/schema.ts, src/lib/db/relations.ts, drizzle/0002_candidate_profile_ownership.sql</files>
  <action>
    1. In `src/lib/db/schema.ts`, add two columns to the `profiles` pgTable definition:
       - `userId: uuid('user_id').references(() => users.id, { onDelete: 'set null' })` -- nullable (existing agency profiles have no user)
       - `duplicateNotes: text('duplicate_notes')` -- nullable, for flagging potential duplicates to admin
       Add an index in the profiles table index callback: `index('profiles_user_id_idx').on(table.userId)`

    2. In `src/lib/db/relations.ts`:
       - Update `profilesRelations` to include a `user` relation: `user: one(users, { fields: [profiles.userId], references: [users.id] })`. This requires changing `relations(profiles, ({ many }) => ...)` to `relations(profiles, ({ one, many }) => ...)`.
       - Update `usersRelations` to include a `candidateProfile` relation: `candidateProfile: one(profiles, { fields: [users.id], references: [profiles.userId] })`. This relation already has `one` available since it uses `({ one, many })`.

    3. Create `drizzle/0002_candidate_profile_ownership.sql` with:
       ```sql
       -- Add userId and duplicateNotes columns to profiles (Drizzle push handles this)
       -- This migration creates the partial unique index that Drizzle cannot express natively

       CREATE UNIQUE INDEX IF NOT EXISTS profiles_user_id_unique
         ON profiles(user_id)
         WHERE user_id IS NOT NULL;
       ```
       This ensures one profile per candidate user while allowing multiple NULL values (agency-uploaded profiles).

    IMPORTANT: Do NOT use `uuid` import with the `unique()` chain on userId -- the uniqueness is handled by the partial index in SQL, not by Drizzle schema. A normal Drizzle unique constraint would reject multiple NULLs.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm schema.ts and relations.ts compile without errors. Verify the SQL file exists and contains the partial unique index statement.
  </verify>
  <done>
    profiles table has userId (nullable FK to users) and duplicateNotes (nullable text) columns in schema.ts. Relations file has bidirectional user-profile links. SQL migration file exists with partial unique index.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create candidate DAL module with ownership-scoped queries</name>
  <files>src/lib/dal/candidate-profiles.ts</files>
  <action>
    Create `src/lib/dal/candidate-profiles.ts` following the established DAL pattern from `src/lib/dal/employer-profiles.ts` (server-only, cache-wrapped functions).

    Include `import 'server-only'` at the top.

    Implement these cached functions:

    1. `getCandidateProfile(userId: string)` -- returns the candidate's own profile with ALL related data (no anonymization -- this is the candidate's own data). Use `db.query.profiles.findFirst()` with:
       - `where: eq(profiles.userId, userId)`
       - `with: { education: true, workHistory: true, barAdmissions: true, profileSpecializations: { with: { specialization: true } }, profileTechnicalDomains: { with: { technicalDomain: true } }, cvUploads: true }`
       - Return `profile ?? null`

    2. `getCandidateUploads(userId: string)` -- returns the candidate's CV upload records ordered by createdAt DESC. Use `db.select().from(cvUploads).where(eq(cvUploads.uploadedBy, userId)).orderBy(desc(cvUploads.createdAt))`.

    3. `checkDuplicateProfiles(name: string, email: string | null)` -- checks for potential duplicate profiles among agency-uploaded profiles (where userId IS NULL). Returns an array of flag strings.
       - If email is provided and non-empty: query `profiles` WHERE `email ILIKE $email` AND `userId IS NULL`. If match found, add flag string: `Email matches existing profile: {name} ({id})`.
       - If name is provided and non-empty: query `profiles` WHERE `name ILIKE $name` AND `userId IS NULL`. If match found, add flag string: `Name matches existing profile: {name} ({id})`.
       - Use `ilike` from drizzle-orm and `isNull` for the userId check.
       - Return the flags array (empty if no matches).

    Import `cache` from 'react', `db` from '@/lib/db', relevant schema tables from '@/lib/db/schema', and `eq`, `desc`, `ilike`, `isNull` from 'drizzle-orm'.
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm the DAL module compiles. Verify it exports getCandidateProfile, getCandidateUploads, and checkDuplicateProfiles.
  </verify>
  <done>
    Candidate DAL module exists at `src/lib/dal/candidate-profiles.ts` with three exported functions: getCandidateProfile (ownership-scoped profile query with all relations), getCandidateUploads (upload history), and checkDuplicateProfiles (duplicate detection against agency profiles).
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- `src/lib/db/schema.ts` contains `userId` and `duplicateNotes` columns on profiles table
- `src/lib/db/relations.ts` contains bidirectional user-profile relation
- `drizzle/0002_candidate_profile_ownership.sql` exists with partial unique index
- `src/lib/dal/candidate-profiles.ts` exports getCandidateProfile, getCandidateUploads, checkDuplicateProfiles
- Candidate DAL uses 'server-only' import and cache() wrapping
</verification>

<success_criteria>
Schema compiles with new userId/duplicateNotes columns on profiles. Relations are bidirectional. SQL migration for partial unique index is ready to run. Candidate DAL provides ownership-scoped data access functions. TypeScript compilation passes.
</success_criteria>

<output>
After completion, create `.planning/phases/07-candidate-self-service/07-01-SUMMARY.md`
</output>
