---
phase: 06-monetization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/db/schema.ts
  - src/lib/db/relations.ts
  - src/lib/stripe.ts
  - src/lib/dal/employer-unlocks.ts
  - src/lib/dal/employer-profiles.ts
  - src/actions/checkout.ts
  - src/app/api/webhooks/stripe/route.ts
  - .env.example
autonomous: true
user_setup:
  - service: stripe
    why: "Payment processing for profile unlocks"
    env_vars:
      - name: STRIPE_SECRET_KEY
        source: "Stripe Dashboard -> Developers -> API keys -> Secret key (use test key sk_test_...)"
      - name: STRIPE_WEBHOOK_SECRET
        source: "Stripe CLI: run 'stripe listen --forward-to localhost:3000/api/webhooks/stripe' to get whsec_... OR Stripe Dashboard -> Developers -> Webhooks -> Signing secret"
      - name: STRIPE_PRICE_AMOUNT
        source: "Set to price in cents, e.g. 9900 for $99.00"
    dashboard_config:
      - task: "Create a Stripe account at stripe.com if you don't have one"
        location: "https://dashboard.stripe.com/register"

must_haves:
  truths:
    - "Stripe Checkout Session is created with correct metadata (employerUserId, profileId)"
    - "Webhook handler verifies Stripe signature before processing any event"
    - "Webhook handler deduplicates events via stripe_events table"
    - "Profile unlock is recorded only after webhook confirmation, never on client redirect"
    - "Employer cannot be double-charged for the same profile (unique constraint + isProfileUnlocked check)"
    - "Full profile DAL returns PII only when unlock record exists"
  artifacts:
    - path: "src/lib/db/schema.ts"
      provides: "profileUnlocks, stripeEvents, profileViews table definitions"
      contains: "profileUnlocks"
    - path: "src/lib/db/relations.ts"
      provides: "Relations for new tables"
      contains: "profileUnlocksRelations"
    - path: "src/lib/stripe.ts"
      provides: "Stripe client singleton"
      contains: "new Stripe"
    - path: "src/lib/dal/employer-unlocks.ts"
      provides: "isProfileUnlocked, getEmployerPurchases functions"
      exports: ["isProfileUnlocked", "getEmployerPurchases"]
    - path: "src/lib/dal/employer-profiles.ts"
      provides: "getFullProfileById function added alongside existing anonymized functions"
      contains: "getFullProfileById"
    - path: "src/actions/checkout.ts"
      provides: "createCheckoutSession server action"
      exports: ["createCheckoutSession"]
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Webhook POST handler with signature verification and idempotency"
      exports: ["POST"]
  key_links:
    - from: "src/actions/checkout.ts"
      to: "src/lib/stripe.ts"
      via: "stripe.checkout.sessions.create()"
      pattern: "stripe\\.checkout\\.sessions\\.create"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/db/schema.ts"
      via: "insert into profileUnlocks on checkout.session.completed"
      pattern: "db\\.insert\\(profileUnlocks\\)"
    - from: "src/actions/checkout.ts"
      to: "src/lib/dal/employer-unlocks.ts"
      via: "isProfileUnlocked check before creating session"
      pattern: "isProfileUnlocked"
    - from: "src/lib/dal/employer-profiles.ts"
      to: "src/lib/dal/employer-unlocks.ts"
      via: "getFullProfileById checks unlock record before returning PII"
      pattern: "profileUnlocks"
---

<objective>
Set up Stripe payment infrastructure and profile unlock backend for the monetization phase.

Purpose: This plan creates the complete backend pipeline for per-profile unlock payments -- from database tables to Stripe integration to DAL functions. Everything the frontend needs to wire unlock buttons and display full profiles.

Output: Database schema for unlocks/events/views, Stripe client, checkout server action, webhook handler, unlock DAL, and full-profile DAL function.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-monetization/06-RESEARCH.md

@src/lib/db/schema.ts
@src/lib/db/relations.ts
@src/lib/db/index.ts
@src/lib/dal/employer-profiles.ts
@src/lib/dal/employer-saved.ts
@src/lib/dal/admin-employers.ts
@src/lib/anonymize.ts
@src/actions/auth.ts
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database schema, relations, Stripe client, and environment setup</name>
  <files>
    src/lib/db/schema.ts
    src/lib/db/relations.ts
    src/lib/stripe.ts
    .env.example
  </files>
  <action>
    1. Install Stripe SDK: `npm install stripe`

    2. Add three new tables to `src/lib/db/schema.ts` (append after the existing `savedProfiles` table). Import `integer` from `drizzle-orm/pg-core` (not currently imported):

       **stripeEvents** -- idempotency dedup table:
       - id: uuid PK defaultRandom
       - stripeEventId: varchar(255) unique notNull
       - eventType: varchar(100) notNull
       - processedAt: timestamp withTimezone defaultNow notNull
       - Indexes: uniqueIndex on stripeEventId

       **profileUnlocks** -- which employer unlocked which candidate:
       - id: uuid PK defaultRandom
       - employerUserId: uuid notNull, references users.id onDelete cascade
       - profileId: uuid notNull, references profiles.id onDelete cascade
       - stripeSessionId: varchar(255) notNull
       - amountPaid: integer notNull (in cents)
       - currency: varchar(3) notNull default 'usd'
       - unlockedAt: timestamp withTimezone defaultNow notNull
       - Indexes: uniqueIndex on (employerUserId, profileId), index on employerUserId, index on profileId

       **profileViews** -- analytics tracking:
       - id: uuid PK defaultRandom
       - employerUserId: uuid notNull, references users.id onDelete cascade
       - profileId: uuid notNull, references profiles.id onDelete cascade
       - viewedAt: timestamp withTimezone defaultNow notNull
       - Indexes: index on profileId, index on employerUserId, index on viewedAt

    3. Update `src/lib/db/relations.ts`:
       - Import the three new tables from schema
       - Add `profileUnlocksRelations`: one-to-one with users (employerUserId -> users.id) and one-to-one with profiles (profileId -> profiles.id)
       - Add `profileViewsRelations`: one-to-one with users and profiles
       - Update `profilesRelations` to add `many(profileUnlocks)` and `many(profileViews)`
       - Update `usersRelations` to add `many(profileUnlocks)` and `many(profileViews)`

    4. Create `src/lib/stripe.ts` -- Stripe client singleton:
       ```typescript
       import 'server-only'
       import Stripe from 'stripe'

       export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
         typescript: true,
       })
       ```

    5. Update `.env.example` -- add Stripe variables after the existing EMAIL_FROM line:
       ```
       # Stripe
       STRIPE_SECRET_KEY="sk_test_..."
       STRIPE_WEBHOOK_SECRET="whsec_..."
       STRIPE_PRICE_AMOUNT="9900"
       NEXT_PUBLIC_URL="http://localhost:3000"
       ```

    Note: NEXT_PUBLIC_URL is needed for Stripe Checkout success/cancel URLs. Check if it already exists as APP_URL -- if so, use APP_URL in the checkout action instead and skip adding NEXT_PUBLIC_URL.
  </action>
  <verify>
    - `npm ls stripe` shows stripe installed
    - `npx tsc --noEmit` passes (no type errors in schema, relations, or stripe.ts)
    - .env.example contains STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, STRIPE_PRICE_AMOUNT
  </verify>
  <done>
    Three new tables defined in schema.ts, relations updated, Stripe client singleton created, .env.example updated with Stripe variables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Unlock DAL, full profile DAL, checkout action, and webhook handler</name>
  <files>
    src/lib/dal/employer-unlocks.ts
    src/lib/dal/employer-profiles.ts
    src/actions/checkout.ts
    src/app/api/webhooks/stripe/route.ts
  </files>
  <action>
    1. Create `src/lib/dal/employer-unlocks.ts` with two cached functions:
       - `isProfileUnlocked(employerUserId, profileId) -> boolean`: SELECT from profileUnlocks WHERE employerUserId AND profileId, limit 1, return boolean
       - `getEmployerPurchases(employerUserId)`: SELECT profileId, amountPaid, currency, unlockedAt FROM profileUnlocks WHERE employerUserId, ORDER BY unlockedAt DESC. Also join with profiles table to get the profile's specializations (for display in purchase history). Return array of { profileId, amountPaid, currency, unlockedAt, specializations: string[] }.

       Follow the pattern in `src/lib/dal/employer-saved.ts` (import 'server-only', cache wrapper, db import, etc.).

    2. Add `getFullProfileById` to `src/lib/dal/employer-profiles.ts`:
       - This is a NEW function alongside the existing anonymized functions. Do NOT modify existing functions.
       - Signature: `getFullProfileById(profileId: string, employerUserId: string): Promise<FullProfileDTO | null>`
       - First verify unlock exists by calling `isProfileUnlocked` from employer-unlocks.ts. If not unlocked, return null.
       - Then query profiles with ALL columns including PII (name, email, phone) and full relations (work history WITH employer name and description, education, barAdmissions, specializations, technicalDomains).
       - Define `FullProfileDTO` type at the top of the file -- same structure as AnonymizedProfileDTO but with additional fields: name, email, phone, and workHistory entries include employer and description.
       - Cache-wrapped like existing functions.
       - Import `profileUnlocks` from schema is NOT needed here -- use the `isProfileUnlocked` DAL function instead for separation.

    3. Create `src/actions/checkout.ts` -- server action for Stripe Checkout:
       - 'use server' directive
       - Import getUser from '@/lib/dal', getEmployerProfile from admin-employers DAL, isProfileUnlocked from employer-unlocks DAL, stripe from stripe.ts, redirect from next/navigation
       - `createCheckoutSession(profileId: string)`:
         - Verify user exists and role is 'employer'
         - Verify employer profile exists and status is 'approved'
         - Check isProfileUnlocked -- if already unlocked, redirect to profile page
         - Create Stripe checkout session with mode: 'payment', inline price_data (unit_amount from STRIPE_PRICE_AMOUNT env var, currency 'usd', product name 'Profile Unlock'), metadata: { employerUserId: user.id, profileId, employerProfileId: employerProfile.id }, customer_email: user.email
         - success_url: `${process.env.APP_URL || process.env.NEXT_PUBLIC_URL || 'http://localhost:3000'}/employer/browse/${profileId}?unlocked=pending`
         - cancel_url: `${process.env.APP_URL || process.env.NEXT_PUBLIC_URL || 'http://localhost:3000'}/employer/browse/${profileId}`
         - Redirect to session.url

    4. Create `src/app/api/webhooks/stripe/route.ts` -- webhook handler:
       - Export POST function only (no auth check -- webhooks are authenticated via signature)
       - Read raw body with `await request.text()` (NEVER use request.json())
       - Get stripe-signature from `request.headers.get('stripe-signature')`
       - Verify with `stripe.webhooks.constructEvent(body, signature, process.env.STRIPE_WEBHOOK_SECRET!)`
       - Idempotency: check stripeEvents table for existing event ID. If found, return { received: true, duplicate: true }
       - Insert event into stripeEvents BEFORE processing (catch unique constraint = concurrent duplicate)
       - Handle `checkout.session.completed`: extract metadata (employerUserId, profileId), verify payment_status is 'paid', insert into profileUnlocks with `.onConflictDoNothing()` on the unique constraint
       - Return NextResponse.json({ received: true }) with status 200
       - Wrap all processing in try/catch, return 500 on unexpected errors

    IMPORTANT anti-patterns to avoid:
    - Do NOT use `await request.json()` in webhook -- raw body needed for signature verification
    - Do NOT use `headers()` from next/headers -- use `request.headers.get()` directly
    - Do NOT add an `includeFullDetails` boolean to existing DAL functions -- keep separate functions
    - Do NOT grant access based on URL parameters -- only database unlock records
  </action>
  <verify>
    - `npx tsc --noEmit` passes (no type errors across all new/modified files)
    - Verify `src/lib/dal/employer-unlocks.ts` exports isProfileUnlocked and getEmployerPurchases
    - Verify `src/lib/dal/employer-profiles.ts` exports getFullProfileById alongside existing functions
    - Verify `src/actions/checkout.ts` has 'use server' directive and exports createCheckoutSession
    - Verify `src/app/api/webhooks/stripe/route.ts` exports POST function
    - Verify webhook route uses `request.text()` not `request.json()`
  </verify>
  <done>
    Complete backend payment pipeline: employer-unlocks DAL with isProfileUnlocked and getEmployerPurchases, full profile DAL with PII access gated by unlock record, checkout server action creating Stripe sessions with metadata, and webhook handler with signature verification, event deduplication, and profile unlock fulfillment. TypeScript compiles without errors.
  </done>
</task>

</tasks>

<verification>
1. `npm ls stripe` confirms stripe is installed
2. `npx tsc --noEmit` passes -- all new files compile without type errors
3. Schema has profileUnlocks, stripeEvents, profileViews tables with correct columns and indexes
4. Relations file references all new tables
5. Webhook route uses `request.text()` for raw body (grep for `request.text()`)
6. Webhook route uses `request.headers.get('stripe-signature')` (not headers() from next/headers)
7. Checkout action checks isProfileUnlocked before creating session (double-charge prevention)
8. profileUnlocks has unique index on (employerUserId, profileId)
9. Webhook inserts profileUnlocks with .onConflictDoNothing()
10. getFullProfileById checks unlock before returning PII
</verification>

<success_criteria>
- Stripe SDK installed and client singleton created
- Three new DB tables defined (profileUnlocks, stripeEvents, profileViews) with proper indexes and constraints
- Checkout server action creates Stripe sessions with correct metadata and redirects
- Webhook handler verifies signatures, deduplicates events, and fulfills unlocks
- Full profile DAL returns PII only when unlock exists
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/06-monetization/06-01-SUMMARY.md`
</output>
