---
phase: 08-job-posting-and-ai-matching
plan: 03
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - src/actions/jobs.ts
  - src/app/(authenticated)/employer/jobs/page.tsx
  - src/app/(authenticated)/employer/jobs/new/page.tsx
  - src/app/(authenticated)/employer/jobs/[id]/page.tsx
  - src/app/(authenticated)/employer/jobs/[id]/edit/page.tsx
  - src/app/(authenticated)/employer/nav.tsx
  - src/components/jobs/job-form.tsx
  - src/components/jobs/match-results.tsx
autonomous: true

must_haves:
  truths:
    - "Employer can create a job listing with title, description, required specializations, experience, location, bar, and technical domains"
    - "Employer can see a list of their job postings with status and match count"
    - "Employer can view a job's detail page showing requirements and match results ranked by score"
    - "Employer can edit an existing job's requirements via a dedicated edit page"
    - "Jobs navigation link appears in the employer nav bar"
    - "Only approved employers can create jobs"
  artifacts:
    - path: "src/actions/jobs.ts"
      provides: "Server actions for job CRUD with Zod validation"
      exports: ["createJobAction", "updateJobAction", "publishJobAction"]
    - path: "src/app/(authenticated)/employer/jobs/page.tsx"
      provides: "Employer job listings page"
      min_lines: 30
    - path: "src/app/(authenticated)/employer/jobs/new/page.tsx"
      provides: "Create new job form page"
      min_lines: 20
    - path: "src/app/(authenticated)/employer/jobs/[id]/page.tsx"
      provides: "Job detail page with match results"
      min_lines: 40
    - path: "src/app/(authenticated)/employer/jobs/[id]/edit/page.tsx"
      provides: "Job edit page wiring updateJobAction to JobForm in edit mode"
      min_lines: 20
    - path: "src/components/jobs/job-form.tsx"
      provides: "Reusable job creation/edit form component"
      min_lines: 50
    - path: "src/components/jobs/match-results.tsx"
      provides: "Match results display with scores, summaries, and recommendations"
      min_lines: 30
  key_links:
    - from: "src/actions/jobs.ts"
      to: "src/lib/dal/jobs.ts"
      via: "calls createJob and updateJob DAL functions"
      pattern: "import.*createJob.*updateJob.*from.*dal/jobs"
    - from: "src/app/(authenticated)/employer/jobs/page.tsx"
      to: "src/lib/dal/jobs.ts"
      via: "calls getJobsByEmployer to load job list"
      pattern: "import.*getJobsByEmployer.*from.*dal/jobs"
    - from: "src/app/(authenticated)/employer/jobs/[id]/page.tsx"
      to: "src/lib/dal/job-matches.ts"
      via: "calls getMatchesForJob to load match results"
      pattern: "import.*getMatchesForJob.*from.*dal/job-matches"
    - from: "src/app/(authenticated)/employer/jobs/[id]/edit/page.tsx"
      to: "src/actions/jobs.ts"
      via: "passes updateJobAction to JobForm"
      pattern: "import.*updateJobAction.*from.*actions/jobs"
    - from: "src/app/(authenticated)/employer/jobs/[id]/edit/page.tsx"
      to: "src/components/jobs/job-form.tsx"
      via: "renders JobForm in edit mode with existing job data"
      pattern: "JobForm.*mode.*edit"
    - from: "src/app/(authenticated)/employer/nav.tsx"
      to: "/employer/jobs"
      via: "nav link to jobs page"
      pattern: "href.*employer/jobs"
---

<objective>
Create employer-facing job management: server actions for job CRUD with Zod validation, job listing/create/detail/edit pages, and match results display. Add jobs link to employer navigation.

Purpose: Enables employers to create job listings, edit their requirements, and view AI-matched candidates ranked by fit score -- the primary value proposition of the platform.
Output: Server actions, 4 new pages (list, create, detail, edit), 2 reusable components, updated nav.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-job-posting-and-ai-matching/08-RESEARCH.md
@.planning/phases/08-job-posting-and-ai-matching/08-01-SUMMARY.md

Key reference files:
@src/actions/checkout.ts -- server action pattern (getUser, role check, approved check)
@src/actions/employers.ts -- server action with useActionState-compatible signature
@src/app/(authenticated)/employer/nav.tsx -- employer nav to extend
@src/app/(authenticated)/employer/browse/page.tsx -- employer page pattern (getUser, approval check, DAL call)
@src/app/(authenticated)/employer/browse/filters.tsx -- multi-select filter pattern
@src/app/(authenticated)/employer/browse/[id]/page.tsx -- detail page pattern
@src/lib/dal/jobs.ts -- job DAL (created in plan 01)
@src/lib/dal/job-matches.ts -- match result DAL (created in plan 01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create job server actions and form component</name>
  <files>src/actions/jobs.ts, src/components/jobs/job-form.tsx</files>
  <action>
**In `src/actions/jobs.ts`:**

Add `'use server'` directive at top.

Define Zod validation schemas:

```typescript
const CreateJobSchema = z.object({
  title: z.string().min(1, 'Title is required').max(255),
  description: z.string().optional(),
  requiredSpecializations: z.array(z.string()).min(1, 'At least one required specialization'),
  preferredSpecializations: z.array(z.string()).optional().default([]),
  minimumExperience: z.coerce.number().int().min(0).optional(),
  preferredLocation: z.string().max(255).optional(),
  requiredBar: z.array(z.string()).optional().default([]),
  requiredTechnicalDomains: z.array(z.string()).optional().default([]),
})
```

Export 3 server actions:

1. `createJobAction(prevState: ActionState | undefined, formData: FormData): Promise<ActionState>` where `ActionState = { success?: boolean; error?: string; jobId?: string }`.
   - Call `getUser()`, verify role is 'employer'.
   - Load employer profile via `getEmployerProfile(user.id)`, verify status is 'approved'.
   - Parse formData: for array fields (specializations, bar, domains), use `formData.getAll('requiredSpecializations')` to get multiple values.
   - Validate with `CreateJobSchema.safeParse()`. On error, return `{ error: formatted validation errors }`.
   - Call `createJob()` from DAL with `employerUserId: user.id` and `createdBy: user.id`. Set initial status to 'draft'.
   - Call `revalidatePath('/employer/jobs')`.
   - Return `{ success: true, jobId }`.

2. `publishJobAction(jobId: string): Promise<ActionState>` -- Changes job status from 'draft' to 'open'. Only the owning employer can publish.
   - Verify user is employer, owns the job.
   - Call `updateJob(jobId, { status: 'open' })`.
   - Revalidate `/employer/jobs` and `/employer/jobs/${jobId}`.
   - Return `{ success: true }`.

3. `updateJobAction(prevState: ActionState | undefined, formData: FormData): Promise<ActionState>` -- Updates an existing job's requirements. Same validation as create. Also calls `invalidateMatchesForJob(jobId)` if any requirement fields changed (to trigger re-matching). Revalidates paths.
   - Call `getUser()`, verify role is 'employer'.
   - Extract `jobId` from formData (hidden input).
   - Load job via `getJobById(jobId)`, verify ownership (job.employerUserId === user.id).
   - Parse and validate remaining fields with `CreateJobSchema.safeParse()`.
   - Call `updateJob(jobId, validatedData)` from DAL.
   - Call `invalidateMatchesForJob(jobId)` from job-matches DAL to clear stale cached matches.
   - Revalidate `/employer/jobs` and `/employer/jobs/${jobId}`.
   - Return `{ success: true, jobId }`.

For all actions, follow the pattern from `checkout.ts`: getUser -> role check -> employer profile check -> business logic.

**In `src/components/jobs/job-form.tsx`:**

'use client' component.

Props: `{ mode: 'create' | 'edit'; initialData?: JobFormData; action: (prevState: ActionState, formData: FormData) => Promise<ActionState> }`

Build a form using shadcn/ui components. Fields:

1. **Title** -- `<Input>` with label
2. **Description** -- `<Textarea>` with label (optional)
3. **Required Specializations** -- Multi-select checkboxes. Use the same IP specialization list that exists in the codebase: Patent Prosecution, Patent Litigation, Trademark, Copyright, Trade Secrets, IP Litigation, Licensing/Technology Transfer. Each selected value becomes a hidden `<input type="hidden" name="requiredSpecializations" value={spec} />`. Display as a grid of `<Checkbox>` components.
4. **Preferred Specializations** -- Same multi-select pattern, same options list.
5. **Minimum Experience** -- `<Input type="number" min="0">` with label (optional, in years)
6. **Preferred Location** -- `<Input>` with label (free text, optional)
7. **Required Bar Admissions** -- Multi-select checkboxes with common values: USPTO, California, New York, Texas, Illinois, DC, Other. Use hidden inputs for form submission.
8. **Required Technical Domains** -- Multi-select checkboxes using existing technical domain categories from the codebase: Electrical Engineering, Mechanical Engineering, Computer Science, Chemistry, Biology/Biotech, Pharmaceutical, Materials Science. Hidden inputs for form submission.

When `mode === 'edit'`, populate all fields from `initialData`. Include a hidden `<input type="hidden" name="jobId" value={initialData.id} />` so updateJobAction can identify the job.

Use `useActionState` with the passed `action` prop. Show validation errors from `state.error`. On success, redirect to `/employer/jobs` (or to `/employer/jobs/${state.jobId}` for create).

Use `useEffect` to redirect on `state.success` via `router.push()`.

Style: Follow existing form patterns in the codebase (employer registration form). Use `<Card>` wrapper, proper spacing, submit `<Button>` at bottom. In edit mode, button text should be "Update Job" instead of "Create Job".
  </action>
  <verify>Run `npx tsc --noEmit` to verify both files compile. Verify createJobAction validates with Zod and checks employer approval. Verify updateJobAction calls invalidateMatchesForJob. Verify the form component handles multi-select arrays properly via hidden inputs and supports both create and edit modes with initialData population.</verify>
  <done>Server actions validate job creation/update/publish with Zod and employer auth. updateJobAction invalidates cached matches when requirements change. Form component renders all job requirement fields with multi-select support for specializations, bar admissions, and technical domains, and properly populates from initialData in edit mode.</done>
</task>

<task type="auto">
  <name>Task 2: Create employer job pages (list, create, detail, edit), match results component, and update nav</name>
  <files>src/app/(authenticated)/employer/jobs/page.tsx, src/app/(authenticated)/employer/jobs/new/page.tsx, src/app/(authenticated)/employer/jobs/[id]/page.tsx, src/app/(authenticated)/employer/jobs/[id]/edit/page.tsx, src/components/jobs/match-results.tsx, src/app/(authenticated)/employer/nav.tsx</files>
  <action>
**In `src/app/(authenticated)/employer/jobs/page.tsx`:**

Server component. Pattern from `employer/browse/page.tsx`:
1. `getUser()` -> verify employer role + approved status
2. Call `getJobsByEmployer(user.id)` from DAL
3. Render a page with heading "My Jobs" and a "Create Job" link/button
4. If no jobs, show empty state: "You haven't created any job listings yet."
5. If jobs exist, render a list/table of jobs as cards or table rows:
   - Each row: Title, Status badge (draft/open/closed/archived with color coding), Match count, Created date
   - Click row/title links to `/employer/jobs/${job.id}`
   - Draft jobs show a "Publish" button (calls `publishJobAction`)
6. Use status color coding: draft=gray, open=green, closed=yellow, archived=red

**In `src/app/(authenticated)/employer/jobs/new/page.tsx`:**

Server component wrapper for the job form:
1. `getUser()` -> verify employer + approved
2. Render heading "Create Job Listing" with breadcrumb back to `/employer/jobs`
3. Render `<JobForm mode="create" action={createJobAction} />`
4. Import `createJobAction` from `@/actions/jobs`

**In `src/app/(authenticated)/employer/jobs/[id]/page.tsx`:**

Server component. Job detail page with match results.
1. `getUser()` -> verify employer + approved
2. Load job via `getJobById(params.id)` -- verify ownership (job.employerUserId === user.id)
3. If not found or not owned, `notFound()`
4. Display job details: title, description, all requirement fields as chips/badges
5. Include an "Edit Job" link to `/employer/jobs/${job.id}/edit` (only if job is still in draft or open status)
6. Show matching status section:
   - If `matchingStatus === 'pending'`: Show "Run Matching" button. This button triggers a client-side fetch to `POST /api/matching/run` with the jobId, then polls `/api/matching/status`. Use a client component for this interactive piece.
   - If `matchingStatus === 'running'`: Show "Matching in progress..." with a spinner. Auto-poll status.
   - If `matchingStatus === 'completed'`: Show match results via `<MatchResults>` component.
   - If `matchingStatus === 'failed'`: Show error message with "Retry" button.
7. Load matches via `getMatchesForJob(jobId)` if status is 'completed'.
8. Pass matches to `<MatchResults matches={matches} />`.

For the "Run Matching" / polling interaction, create a small client component `MatchingTrigger` within the same file (or as a separate component) that:
- Has a "Run Matching" button
- On click: calls `POST /api/matching/run` via fetch
- Then polls `GET /api/matching/status?jobId=xxx` every 2 seconds
- When status changes to 'completed', calls `router.refresh()` to reload server component data
- Shows appropriate loading state during matching

**In `src/app/(authenticated)/employer/jobs/[id]/edit/page.tsx`:**

Server component. Employer job edit page. This wires `updateJobAction` to `JobForm` in edit mode, ensuring `updateJobAction` and `mode='edit'` are not dead code.

1. `getUser()` -> verify employer role + approved status
2. Load job via `getJobById(params.id)` -- verify ownership (job.employerUserId === user.id)
3. If not found or not owned, `notFound()`
4. Build `initialData` from the loaded job: `{ id: job.id, title: job.title, description: job.description, requiredSpecializations: job.requiredSpecializations ?? [], preferredSpecializations: job.preferredSpecializations ?? [], minimumExperience: job.minimumExperience, preferredLocation: job.preferredLocation, requiredBar: job.requiredBar ?? [], requiredTechnicalDomains: job.requiredTechnicalDomains ?? [] }`
5. Render heading "Edit Job" with breadcrumb: `/employer/jobs` -> `/employer/jobs/${job.id}` -> Edit
6. Render `<JobForm mode="edit" initialData={initialData} action={updateJobAction} />`
7. Import `updateJobAction` from `@/actions/jobs`

**In `src/components/jobs/match-results.tsx`:**

Server component. Props: `{ matches: JobMatchDTO[] }` where `JobMatchDTO` comes from the DAL.

Display matches as a list of cards, ordered by overallScore DESC:
1. Each match card shows:
   - **Overall Score** as a large number with color coding (75+: green, 50-74: yellow, 25-49: orange, 0-24: red)
   - **Recommendation** badge ("Strong Match", "Good Match", "Partial Match", "Weak Match") with matching colors
   - **Summary** text (2-3 sentences from Claude)
   - **Sub-scores** as a horizontal bar or grid: Specialization (30%), Experience (25%), Technical (20%), Bar (15%), Location (10%) -- each showing score/100 and one-line explanation
   - **Profile link**: "View Profile" link to `/employer/browse/${match.profileId}` so employer can see the anonymized (or unlocked) candidate profile
2. If no matches, show: "No matching candidates found. Try broadening your job requirements."
3. Show match count in header: "X candidates matched"

Use shadcn/ui `<Card>`, `<Badge>`, `<Progress>` components for clean display.

**In `src/app/(authenticated)/employer/nav.tsx`:**

Add a new nav link for Jobs between Browse and Saved:

```typescript
{ href: '/employer/jobs', label: 'Jobs', icon: Briefcase, exact: false },
```

Import `Briefcase` from `lucide-react`. Keep existing nav items, just add this one.
  </action>
  <verify>Run `npx tsc --noEmit` to verify all files compile. Verify the employer nav has a Jobs link. Verify the jobs list page loads jobs for the current employer. Verify the detail page shows match results when matching is completed. Verify the edit page loads job data and renders JobForm with mode='edit' and initialData. Verify the detail page has an "Edit Job" link.</verify>
  <done>Employer can navigate to Jobs via nav, see their job listings, create new jobs via form, view job details with match results, and edit existing jobs. Match results show scores, recommendations, sub-scores, and summaries with profile links. The edit page wires updateJobAction and JobForm edit mode so neither is dead code.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with zero errors
- Employer nav has Jobs link between Browse and Saved
- `/employer/jobs` renders job list for authenticated employer
- `/employer/jobs/new` renders job creation form with all requirement fields
- `/employer/jobs/[id]` renders job detail with match results section and "Edit Job" link
- `/employer/jobs/[id]/edit` renders job form in edit mode with pre-populated fields
- Server actions validate with Zod and check employer approval
- updateJobAction invalidates cached matches when requirements change
- Match results component shows scores, recommendations, and sub-scores
- Only approved employers can access job features
- No dead code: updateJobAction is called by edit page, JobForm mode='edit' is used by edit page
</verification>

<success_criteria>
Employer can create a job listing with structured requirements, see their jobs in a list, view individual job details with AI-matched candidate results sorted by fit score with plain-English explanations, and edit existing job requirements (which invalidates cached matches for re-matching).
</success_criteria>

<output>
After completion, create `.planning/phases/08-job-posting-and-ai-matching/08-03-SUMMARY.md`
</output>
